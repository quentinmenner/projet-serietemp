demo()
library(tseries)
# Importation et structuration des donnï¿½es ####
datafile <- "projet-serietemp/valeurs_mensuelles_2.csv"
acf(ts_data) # Il semble que la sï¿½rie reprï¿½sente un AR pure
library(zoo)
library(zoo)
library(tseries)
library(lmtest)
library(forecast)
library(ggplot2)
library(urca)
library(tidyverse)
library(lubridate)
library(xts)
library(patchwork)
# Importation et structuration des donnï¿½es ####
datafile <- "projet-serietemp/valeurs_mensuelles_2.csv"
data <- read.csv(datafile, sep = ";") %>% arrange(Periode)
setwd("~/Ordi Quentin/Documents/ENSAE/Séries temporelles linéaires/Projet/projet-serietemp")
# Importation et structuration des donnï¿½es ####
datafile <- "projet-serietemp/valeurs_mensuelles_2.csv"
data <- read.csv(datafile, sep = ";") %>% arrange(Periode)
# Importation et structuration des donnï¿½es ####
datafile <- "valeurs_mensuelles_2.csv"
data <- read.csv(datafile, sep = ";") %>% arrange(Periode)
ts_data = ts(data$Valeur, start = c(1985,01), freq = 12)
plot(ts_data, type = "l")
plot(ts_data, type = "l")
acf(ts_data) # Il semble que la sï¿½rie reprï¿½sente un AR pure
## Question 1
# Saisonnalitï¿½ ?
decomposition_saison = data %>%
mutate(year = str_sub(Periode, end = 4)) %>%
mutate(month = str_sub(Periode, -2)) %>%
group_by(month) %>%
summarise(moy_mens = mean(Valeur))
plot(decomposition_saison$moy_mens)
#On observe une trï¿½s lï¿½gï¿½re saisonnalitï¿½
(max(decomposition_saison$moy_mens) - min(decomposition_saison$moy_mens))/min(decomposition_saison$moy_mens)
# Tendance ?
data_tendance = data %>%
mutate(index = index(data))
# Régression linéaire sur le temps
scatterplot(Valeur ~ index, data = data_tendance,
smoother = FALSE, grid = FALSE, frame = FALSE)
library("car")
# Régression linéaire sur le temps
scatterplot(Valeur ~ index, data = data_tendance,
smoother = FALSE, grid = FALSE, frame = FALSE)
# Une tendance ï¿½ la hausse semble se dï¿½gager
diff_ts = diff(ts_data, 1)
plot(diff_ts)
# ADF test
test_adf = urca::ur.df(diff_ts)
summary(test_adf)
# PP test
test_pp = tseries::pp.test(diff_ts) # test utilisï¿½ dans corrigï¿½
summary(test_pp)
# KPSS
test_kpss = urca::ur.kpss(diff_ts)
summary(test_kpss)
# Reprï¿½sentation de la sï¿½rie avant / aprï¿½s
plot(diff_ts)
# Question 4 : Estimation un ARMA(p,q)
acf(diff_ts)
pacf(diff_ts)
# Testons cette hypothï¿½ses
model_maxi <- arima(diff_ts, order = c(2,0,1))
residus_maxi <- residuals(model_maxi)
View(model_maxi)
ggAcf
# Testons cette hypothï¿½ses
model_maxi <- arima(diff_ts, order = c(2,0,1))
residus_maxi <- residuals(model_maxi)
# Parait bon :
ggAcf(residus_maxi) + ggPacf(residus_maxi)
portes::LjungBox(model_maxi, order = 6)
lmtest::coeftest(model_maxi) # aucun coefficient n'est significatif
# Testons cette hypothï¿½ses
model_maxi <- arima(diff_ts, order = c(2,0,3))
residus_maxi <- residuals(model_maxi)
# Parait bon :
ggAcf(residus_maxi) + ggPacf(residus_maxi)
portes::LjungBox(model_maxi, order = 6)
lmtest::coeftest(model_maxi) # aucun coefficient n'est significatif
evaluation_model <- function(order, x = diff_ts, lags = 24,...){
model <- forecast::Arima(x, order = order,...)
residus <- residuals(model)
# Test d'autocorrï¿½lation des rï¿½sidus
lbtest <- t(sapply(1:lags,function(l){
if(l <=  length(coef(model))){
b <- list(statistic = NA, p.value = NA)
}else{
b <- Box.test(residus,"Ljung-Box",lag = l,
fitdf = length(coef(model))
)
}
data.frame(lag = l,
b$statistic,
b$p.value
)
}))
# on ajoute un tryCatch pour ï¿½viter les erreurs
ttest <- tryCatch(lmtest::coeftest(model), error = NULL)
qualite <- c(AIC(model), BIC(model), accuracy(model))
names(qualite) <- c("AIC", "BIC", colnames(accuracy(model)))
list(model = model,
ttest = ttest,
lbtest = lbtest,
qualite = qualite)
}
models_possibles <- expand.grid(p = c(0, 1, 2), d = 0, q = c(0, 1, 2, 3))
models_evalues <- apply(models_possibles,1, evaluation_model)
names(models_evalues) <- sprintf("ARIMA(%i,%i,%i)", models_possibles[,"p"],
models_possibles[,"d"], models_possibles[,"q"])
models_evalues$`ARIMA(0,0,0)`
models_evalues$`ARIMA(1,0,0)`
models_evalues$`ARIMA(2,0,0)`
models_evalues$`ARIMA(0,0,1)`
models_evalues$`ARIMA(1,0,1)`
models_evalues$`ARIMA(2,0,1)`
models_evalues$`ARIMA(0,0,2)`
models_evalues$`ARIMA(1,0,2)`
models_evalues$`ARIMA(2,0,2)`
models_evalues$`ARIMA(0,0,3)`
models_evalues$`ARIMA(1,0,3)`
models_evalues$`ARIMA(2,0,3)`
nom_modeles_retenus = c('ARIMA(1,0,0)', 'ARIMA(0,0,1)', 'ARIMA(2,0,1)')
modeles_retenus <- models_evalues[nom_modeles_retenus]
qualite_modeles_retenus <- sapply(modeles_retenus, function(x) x$qualite)
round(qualite_modeles_retenus,4)
apply(qualite_modeles_retenus,1,function(x) colnames(qualite_modeles_retenus)[which.min(x)])
# Finalement on opte pour un ARIMA(1,1,0)
model <- Arima(ts_data, order = c(1,1,0))
model
checkresiduals(model)
